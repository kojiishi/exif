using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.Globalization;
using System.IO;
using System.Linq;

namespace Exif {
    public enum ExifTag {
        EquipMake = 0x010F,
        EquipModel = 0x0110,
        Orientation = 0x0112,
        ExifDTOrig = 0x9003,
        Flash = 0x9209
    }

    public enum ExifTagType {
        Byte = 1,
        Ascii = 2,
        UInt16 = 3,
        UInt32 = 4,
        URational = 5,
        Undefined = 7,
        SInt32 = 9,
        SRational = 10
    }

    public static partial class ImageExtensions {
        #region EXIF Core

        public static object ExifValue(this PropertyItem item) {
            switch ((ExifTagType)item.Type) {
            case ExifTagType.Byte:
                Debug.Assert(item.Len == 1);
                return item.Value[0];
            case ExifTagType.UInt16:
                Debug.Assert(item.Len == 2);
                return BitConverter.ToUInt16(item.Value, 0);
            case ExifTagType.Ascii:
                return System.Text.Encoding.ASCII.GetString(item.Value, 0, item.Len - 1);
            default:
                throw new NotSupportedException();
            }
        }

        public static object ExifValue(this Image image, ExifTag tag) {
            PropertyItem item = image.GetPropertyItemOrDefault(tag);
            if (item == null)
                return null;
            return ExifValue(item);
        }

        /// <summary>
        /// Returns null if the tag is not found,
        /// instead of throwing ArgumentException as GetPropertyItem does.
        /// </summary>
        public static PropertyItem GetPropertyItemOrDefault(this Image image, ExifTag tag) {
            // return image.PropertyItems.FirstOrDefault(i => i.Id == (int)tag);
            // Going through image.PropertyItems does not work with image files
            // generated by SONY cameras such as CYBERSHOT.
            // .NET raises NullReferenceException if there are any EXIF tag with their length=0,
            // and SONY cameras generate such tag.
            try {
                return image.GetPropertyItem((int)tag);
            } catch (ArgumentException) {
#if DEBUG
            } catch (Exception err) {
                Debug.Fail(err.ToString());
#endif
            }
            return null;
        }

        #endregion

        #region EXIF Type Conversions

        public static int ExifIntValue(this Image image, ExifTag tag) {
            return Convert.ToInt32(ExifValue(image, tag));
        }

        public static string ExifStringValue(this Image image, ExifTag tag) {
            return Convert.ToString(ExifValue(image, tag));
        }

        public static DateTime? ExifDateTimeValueOrDefault(this Image image, ExifTag tag) {
            string value = (string)ExifValue(image, tag);
            if (value == null)
                return null;
            return DateTime.ParseExact(value, "yyyy:MM:dd HH:mm:ss", CultureInfo.InvariantCulture);
        }

        #endregion

        #region EXIF Properties

        public static DateTime? ExifOriginalDateTimeOrDefault(this Image img) {
            return ExifDateTimeValueOrDefault(img, ExifTag.ExifDTOrig);
        }

        public static string ExifEquipModel(this Image image) {
            return ExifStringValue(image, ExifTag.EquipModel);
        }

        #endregion

        #region EXIF Orientation

        /// <summary>
        /// This method is not lossless.
        /// Use <see cref="SaveWithOrientationAdjustedByExif"/> for lossless rotate/flip.
        /// </summary>
        /// <param name="image"></param>
        public static void RotateFlipByExifOrientation(this Image image) {
            var type = image.RotateFlipTypeOfExifOrientation();
            if (type == RotateFlipType.RotateNoneFlipNone)
                return;
            image.RotateFlip(type);
        }

        /// <summary>
        /// Save rotated or flipped image using EXIF orientation information.
        /// This method uses JPEG lossless rotation.
        /// </summary>
        /// <param name="image"></param>
        /// <param name="stream"></param>
        /// <param name="encoder"></param>
        public static void SaveWithOrientationAdjustedByExif(this Image image, Stream stream, ImageCodecInfo encoder) {
            EncoderParameters prms = image.GetEncoderParametersToAdjustExifOrientation();
            if (prms != null)
                image.RemovePropertyItem((int)ExifTag.Orientation);
            image.Save(stream, encoder, prms);
        }

        public static void SaveWithOrientationAdjustedByExif(this Image image, string filename, ImageCodecInfo encoder) {
            EncoderParameters prms = image.GetEncoderParametersToAdjustExifOrientation();
            if (prms != null)
                image.RemovePropertyItem((int)ExifTag.Orientation);
            image.Save(filename, encoder, prms);
        }

        static EncoderParameters GetEncoderParametersToAdjustExifOrientation(this Image img) {
            var type = img.RotateFlipTypeOfExifOrientation();
            return EncoderParametersForJpegLosslessRotation(type);
        }

        static RotateFlipType RotateFlipTypeOfExifOrientation(this Image img) {
            int orientation = ExifIntValue(img, ExifTag.Orientation);
            switch (orientation) {
            case 1: // The 0th row is at the visual top of the image, and the 0th column is the visual left-hand side.
                return RotateFlipType.RotateNoneFlipNone;
            case 2: // The 0th row is at the visual top of the image, and the 0th column is the visual right-hand side.
                return RotateFlipType.RotateNoneFlipX;
            case 3: // The 0th row is at the visual bottom of the image, and the 0th column is the visual right-hand side.
                return RotateFlipType.RotateNoneFlipXY;
            case 4: // The 0th row is at the visual bottom of the image, and the 0th column is the visual left-hand side.
                return RotateFlipType.RotateNoneFlipY;
            case 5: // The 0th row is the visual left-hand side of of the image, and the 0th column is the visual top.
                return RotateFlipType.Rotate270FlipX;
            case 6: // The 0th row is the visual right -hand side of of the image, and the 0th column is the visual top.
                return RotateFlipType.Rotate90FlipNone;
            case 7: // The 0th row is the visual right -hand side of of the image, and the 0th column is the visual bottom.
                return RotateFlipType.Rotate90FlipY;
            case 8: // The 0th row is the visual left-hand side of of the image, and the 0th column is the visual bottom.
                return RotateFlipType.Rotate270FlipNone;
            default:
                throw new NotSupportedException();
            }
        }

        static EncoderParameters EncoderParametersForJpegLosslessRotation(RotateFlipType type) {
            // http://www.codeproject.com/cs/media/JPEGviewer.asp
            // http://msdn.microsoft.com/library/en-us/gdicpp/GDIPlus/GDIPlusReference/Enumerations/EncoderValue.asp
            // http://msdn.microsoft.com/library/en-us/gdicpp/GDIPlus/UsingGDIPlus/UsingImageEncodersandDecoders/TransformingaJPEGImageWithoutLossofInformation.asp
            var prms = new List<EncoderValue>();
            switch (type) {
            case RotateFlipType.RotateNoneFlipNone:
                break;
            case RotateFlipType.RotateNoneFlipX:
                prms.Add(EncoderValue.TransformFlipHorizontal);
                break;
            case RotateFlipType.RotateNoneFlipXY:
                prms.Add(EncoderValue.TransformRotate180);
                //prms.Add(EncoderValue.TransformFlipHorizontal);
                //prms.Add(EncoderValue.TransformFlipVertical);
                break;
            case RotateFlipType.RotateNoneFlipY:
                prms.Add(EncoderValue.TransformFlipVertical);
                break;
            case RotateFlipType.Rotate90FlipNone:
                prms.Add(EncoderValue.TransformRotate90);
                break;
            case RotateFlipType.Rotate90FlipX:
                prms.Add(EncoderValue.TransformRotate90);
                prms.Add(EncoderValue.TransformFlipHorizontal);
                break;
            case RotateFlipType.Rotate90FlipXY:
                prms.Add(EncoderValue.TransformRotate270);
                //prms.Add(EncoderValue.TransformRotate90);
                //prms.Add(EncoderValue.TransformFlipHorizontal);
                //prms.Add(EncoderValue.TransformFlipVertical);
                break;
            case RotateFlipType.Rotate90FlipY:
                prms.Add(EncoderValue.TransformRotate90);
                prms.Add(EncoderValue.TransformFlipVertical);
                break;
#if THESE_VALUES_ARE_SYNONYM
            case RotateFlipType.Rotate180FlipNone:
            case RotateFlipType.Rotate180FlipX:
            case RotateFlipType.Rotate180FlipXY:
            case RotateFlipType.Rotate180FlipY:
            case RotateFlipType.Rotate270FlipNone:
            case RotateFlipType.Rotate270FlipX:
            case RotateFlipType.Rotate270FlipXY:
            case RotateFlipType.Rotate270FlipY:
#endif
            default:
                throw new ArgumentException();
            }

            if (prms.Count == 0)
                return null;

            EncoderParameters parameters = new EncoderParameters(prms.Count);
            System.Drawing.Imaging.Encoder enc = System.Drawing.Imaging.Encoder.Transformation;
            for (int i = 0; i < prms.Count; i++) {
                EncoderValue value = (EncoderValue)prms[i];
                parameters.Param[i] = new EncoderParameter(enc, (long)value);
            }
            return parameters;
        }

        #endregion
    }
}
